<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Pyfcm by olucurious</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Pyfcm</h1>
      <h2 class="project-tagline">Python client for FCM - Firebase Cloud Messaging (Android &amp; iOS)</h2>
      <a href="https://github.com/olucurious/PyFCM" class="btn">View on GitHub</a>
      <a href="https://github.com/olucurious/PyFCM/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/olucurious/PyFCM/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <hr>

<p>PyFCM</p>

<hr>

<p>|version| |license| </p>

<p>Python client for FCM - Firebase Cloud Messaging (Android &amp; iOS)</p>

<p>Firebase Cloud Messaging (FCM) is the new version of GCM. It inherits the reliable and scalable GCM infrastructure, plus new features. GCM users are strongly recommended to upgrade to FCM.</p>

<p>Using FCM, you can notify a client app that new email or other data is available to sync. You can send notifications to drive user reengagement and retention. For use cases such as instant messaging, a message can transfer a payload of up to 4KB to a client app.</p>

<p>For more information, visit: <a href="https://firebase.google.com/docs/cloud-messaging/">https://firebase.google.com/docs/cloud-messaging/</a></p>

<h1>
<a id="links" class="anchor" href="#links" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Links</h1>

<ul>
<li>Project: <a href="https://github.com/olucurious/pyfcm">https://github.com/olucurious/pyfcm</a>
</li>
<li>PyPi: <a href="https://pypi.python.org/pypi/pyfcm/">https://pypi.python.org/pypi/pyfcm/</a>
</li>
</ul>

<h1>
<a id="quickstart" class="anchor" href="#quickstart" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quickstart</h1>

<p>Install using pip:</p>

<p>::</p>

<pre><code>pip install pyfcm

OR

pip install git+https://github.com/olucurious/PyFCM.git
</code></pre>

<p>PyFCM supports Android and iOS.</p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h2>

<p>Send notifications using the <code>FCMNotification</code> class:</p>

<p>.. code-block:: python</p>

<pre><code># Send to single device.
from pyfcm import FCMNotification

push_service = FCMNotification(api_key="&lt;api-key&gt;")

# OR initialize with proxies

proxy_dict = {
          "http"  : "http://127.0.0.1",
          "https" : "http://127.0.0.1",
        }
push_service = FCMNotification(api_key="&lt;api-key&gt;", proxy_dict=proxy_dict)

# Your api-key can be gotten from:  https://console.firebase.google.com/project/&lt;project-name&gt;/settings/cloudmessaging

registration_id = "&lt;device registration_id&gt;"
message_title = "Uber update"
message_body = "Hi john, your customized news for today is ready"
result = push_service.notify_single_device(registration_id=registration_id, message_title=message_title, message_body=message_body)

# Send to multiple devices by passing a list of ids.
registration_ids = ["&lt;device registration_id 1&gt;", "&lt;device registration_id 2&gt;", ...]
message_title = "Uber update"
message_body = "Hope you're having fun this weekend, don't forget to check today's news"
result = push_service.notify_multiple_devices(registration_ids=registration_ids, message_title=message_title, message_body=message_body)

print result
</code></pre>

<p>Send a data message.</p>

<p>.. code-block:: python</p>

<pre><code># With FCM, you can send two types of messages to clients:
# 1. Notification messages, sometimes thought of as "display messages."
# 2. Data messages, which are handled by the client app.

# Client app is responsible for processing data messages. Data messages have only custom key-value pairs. (Python dict)
# Data messages let developers send up to 4KB of custom key-value pairs.

# Sending a notification with data message payload
data_message = {
    "Nick" : "Mario",
    "body" : "great match!",
    "Room" : "PortugalVSDenmark"
}
# To multiple devices
result = push_service.notify_multiple_devices(registration_ids=registration_ids, message_body=message_body, data_message=data_message)
# To a single device
result = push_service.notify_single_device(registration_id=registration_id, message_body=message_body, data_message=data_message)

# Sending a data message only payload, do NOT include message_body
# To multiple devices
result = push_service.notify_multiple_devices(registration_ids=registration_ids, data_message=data_message)
# To a single device
result = push_service.notify_single_device(registration_id=registration_id, data_message=data_message)

# Use notification messages when you want FCM to handle displaying a notification on your app's behalf.
# Use data messages when you just want to process the messages only in your app.
# PyFCM can send a message including both notification and data payloads.
# In such cases, FCM handles displaying the notification payload, and the client app handles the data payload.
</code></pre>

<p>Send a low priority message.</p>

<p>.. code-block:: python</p>

<pre><code># The default is low_priority == False
result = push_service.notify_multiple_devices(registration_ids=registration_ids, message_body=message, low_priority=True)
</code></pre>

<p>Sending a message to a topic.</p>

<p>.. code-block:: python</p>

<pre><code># Send a message to devices subscribed to a topic.
result = push_service.notify_topic_subscribers(topic_name="news", message_body=message)

# Conditional topic messaging
topic_condition = "'TopicA' in topics &amp;&amp; ('TopicB' in topics || 'TopicC' in topics)"
result = push_service.notify_topic_subscribers(message_body=message, condition=topic_condition)
# FCM first evaluates any conditions in parentheses, and then evaluates the expression from left to right.
# In the above expression, a user subscribed to any single topic does not receive the message. Likewise,
# a user who does not subscribe to TopicA does not receive the message. These combinations do receive it:
# TopicA and TopicB
# TopicA and TopicC
# Conditions for topics support two operators per expression, and parentheses are supported.
# For more information, check: https://firebase.google.com/docs/cloud-messaging/topic-messaging
</code></pre>

<p>Other argument options</p>

<p>::</p>

<pre><code>collapse_key (str, optional): Identifier for a group of messages
    that can be collapsed so that only the last message gets sent
    when delivery can be resumed. Defaults to `None`.
delay_while_idle (bool, optional): If `True` indicates that the
    message should not be sent until the device becomes active.
time_to_live (int, optional): How long (in seconds) the message
    should be kept in FCM storage if the device is offline. The
    maximum time to live supported is 4 weeks. Defaults to ``None``
    which uses the FCM default of 4 weeks.
low_priority (boolean, optional): Whether to send notification with
    the low priority flag. Defaults to `False`.
restricted_package_name (str, optional): Package name of the
    application where the registration IDs must match in order to
    receive the message. Defaults to `None`.
dry_run (bool, optional): If `True` no message will be sent but
    request will be tested.
</code></pre>

<p>Access response data.</p>

<p>.. code-block:: python</p>

<pre><code># Response from FCM Server.
print result['multicast_id'] #Unique ID (number) identifying the multicast message.
print result['success'] #Number of messages that were processed without an error.
print result['failure'] #Number of messages that could not be processed.
print result['canonical_ids'] #Number of results that contain a canonical registration token.
print result['results'] #Array of objects representing the status of the messages processed.

# The result objects are listed in the same order as the request (i.e., for each registration ID in the request,
# its result is listed in the same index in the response).
# message_id: String specifying a unique ID for each successfully processed message.
# registration_id: Optional string specifying the canonical registration token for the client app that the message
# was processed and sent to. Sender should use this value as the registration token for future requests. Otherwise,
# the messages might be rejected.
# error: String specifying the error that occurred when processing the message for the recipient
</code></pre>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2>

<p>The MIT License (MIT). Please see LICENSE.rst for more information.</p>

<p>::</p>

<pre><code>Copyright (c) 2016 Emmanuel Adegbite

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>

<p>.. |version| image:: <a href="http://img.shields.io/pypi/v/pyfcm.svg?style=flat-square">http://img.shields.io/pypi/v/pyfcm.svg?style=flat-square</a>
    :target: <a href="https://pypi.python.org/pypi/pyfcm/">https://pypi.python.org/pypi/pyfcm/</a></p>

<p>.. |license| image:: <a href="http://img.shields.io/pypi/l/pyfcm.svg?style=flat-square">http://img.shields.io/pypi/l/pyfcm.svg?style=flat-square</a>
    :target: <a href="https://pypi.python.org/pypi/pyfcm/">https://pypi.python.org/pypi/pyfcm/</a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/olucurious/PyFCM">Pyfcm</a> is maintained by <a href="https://github.com/olucurious">olucurious</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
